
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>CuckooPowerCP</title><meta name="generator" content="MATLAB 8.5"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2019-10-06"><meta name="DC.source" content="CuckooPowerCP.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#2">User Input</a></li><li><a href="#3">Initializing the Cuckoo Algorithm</a></li><li><a href="#4">Geting Current best Solution 1</a></li><li><a href="#5">Starting the iteration</a></li><li><a href="#7">Generate new solutions (but keep the current best)</a></li><li><a href="#9">Application of simple constraints 1</a></li><li><a href="#11">end of get_cuckoos</a></li><li><a href="#12">Geting Current best Solution 2</a></li><li><a href="#13">function new_nest=empty_nests(nest,Lb,Ub,pa) ;</a></li><li><a href="#14">New solution by biased/selective random walks</a></li><li><a href="#15">Geting Current best Solution 3</a></li><li><a href="#17">Result Display</a></li></ul></div><pre class="codeinput">clc;clear;close <span class="string">all</span>;
tic
</pre><h2>User Input<a name="2"></a></h2><pre class="codeinput">DistLoadFlowSolution=powerflow;
<span class="comment">% Function Input</span>
User.Function=<span class="string">'ObjfuncPoweRnLSF'</span>;
User.NumbVar=4;
<span class="comment">% User.Lb=[-20,-10,-5,-1];</span>
<span class="comment">% User.Ub=[20,10,5,1];</span>

Standard = true;
Bus_Data = <span class="string">'Enugu '</span>;
bn=33;

User.MaxIter=50;
User.Lb=[150 1];
User.Ub=[1500 bn];

<span class="comment">% User.Lb=[0 0 0];</span>
<span class="comment">% User.Ub=[2.0  2  2];</span>
<span class="comment">% Cuckoo Input</span>
User.NumNest=25;
<span class="comment">%Levy Flight Input</span>
User.beta=3/2;
pa=0.25;
</pre><h2>Initializing the Cuckoo Algorithm<a name="3"></a></h2><pre class="codeinput">SampleNest.CPnLoc=[];
SampleNest.PLosVolt=[];
Nest=repmat(SampleNest,User.NumNest,1);
<span class="keyword">for</span> i=1:User.NumNest
<span class="comment">%     Nest(i).Position=round(User.Lb+(User.Ub-User.Lb).*rand(size(User.Lb)));</span>
    Nest(i).CPnLoc=round(User.Lb+(User.Ub-User.Lb).*rand(size(User.Lb)));

       DistLoadFlowCPSolution=powerflowCP(Nest(i).CPnLoc(1,1),Nest(i).CPnLoc(1,2));

       Nest(i).CostPLos=[DistLoadFlowCPSolution.PtLosskW];
       Nest(i).CostPbrLos=[DistLoadFlowCPSolution.Pbrloss];
       Nest(i).CostVact=[DistLoadFlowCPSolution.Vactual];
       Nest(i).CostVolt=[DistLoadFlowCPSolution.VmagPU];
       Nest(i).CostVSI=[DistLoadFlowCPSolution.VSI];
       Nest(i).CostMinVolt=[DistLoadFlowCPSolution.minVSI];
       Nest(i).CostLSF=[DistLoadFlowCPSolution.LSF];

       Nest(i).CostVDI=[DistLoadFlowCPSolution.VDI];
       Nest(i).CostVDIsum=[DistLoadFlowCPSolution.VDIsum];

       Nest(i).CostVangle=[DistLoadFlowCPSolution.Vangle];
       Nest(i).CostQtLos=[DistLoadFlowCPSolution.QtLosskVAr];
       Nest(i).CostQbrLos=[DistLoadFlowCPSolution.Qbrloss];
       Nest(i).CostSLos=[DistLoadFlowCPSolution.SLosskVA];
<span class="keyword">end</span>
</pre><h2>Geting Current best Solution 1<a name="4"></a></h2><pre class="codeinput">fitness=10^10*ones(User.NumNest,1);
<span class="comment">% function</span>
<span class="comment">% [BestNest.Cost,Bestnest,Nest.Position,fitness]=get_best_nest(Nest.Position,Nest.Position,fitness);</span>
<span class="keyword">for</span> j=1:User.NumNest

    Nest(j).PLosVolt=feval(User.Function,<span class="keyword">...</span>
            Nest(j).CostPLos,Nest(j).CostLSF);

<span class="comment">%     Nest(j).PLosVolt=feval(User.Function,...</span>
<span class="comment">%             Nest(j).CostPLos,Nest(j).CostMinVolt,Nest(j).CostQtLos);</span>
    <span class="keyword">if</span> Nest(j).PLosVolt&lt;=fitness(j)
        fitness(j)=Nest(j).PLosVolt;
        Nest(j).CPnLoc=Nest(j).CPnLoc;
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">% Find the current best</span>
[BestNest.PLosVolt,K]=min(fitness) ;
BestNest.CPnLoc=Nest(K).CPnLoc;
        BestNest.CostPLos       =    Nest(K).CostPLos;
        BestNest.CostPbrLos     =    Nest(K).CostPbrLos;
        BestNest.CostVact       =    Nest(K).CostVact;
        BestNest.CostVolt       =    Nest(K).CostVolt;
        BestNest.CostVSI        =    Nest(K).CostVSI;
        BestNest.CostLSF        =    Nest(K).CostLSF;

        BestNest.CostVDI        =    Nest(K).CostVDI;
        BestNest.CostVDIsum        =    Nest(K).CostVDIsum;

        BestNest.CostMinVolt    =    Nest(K).CostMinVolt;
        BestNest.CostVangle     =    Nest(K).CostVangle;
        BestNest.CostQtLos      =    Nest(K).CostQtLos;
        BestNest.CostQbrLos     =    Nest(K).CostQbrLos;
        BestNest.CostSLos       =    Nest(K).CostSLos;
<span class="comment">%end of get_best_nest</span>

New_Nest=Nest; <span class="comment">% Just preallocting New_Nest</span>
</pre><h2>Starting the iteration<a name="5"></a></h2><pre class="codeinput"><span class="keyword">for</span> iter =1:User.MaxIter
</pre><h2>Generate new solutions (but keep the current best)<a name="7"></a></h2><pre class="codeinput"><span class="comment">%fuction New_Nest.Postion=get_cuckoos(Nest.Position,Bestnest.Position,User.Lb,User.Ub);</span>
<span class="comment">% Note arg1 is calling in the number os nest (i.e Nest.Postion=User.NumNest)</span>
sigma=(gamma(1+User.beta)*sin(pi*User.beta/2)/(gamma((1+User.beta)/2)*User.beta*2^((User.beta-1)/2)))^(1/User.beta);
<span class="keyword">for</span> j=1:User.NumNest
</pre><pre class="codeinput">    <span class="comment">% implementing Levy Flight for each nest</span>
    s=Nest(j).CPnLoc;

     <span class="comment">% Levy flights by Mantegna's algorithm</span>
    u=randn(size(s))*sigma;
    v=randn(size(s));
    step=u./abs(v).^(1/User.beta);

    stepsize=0.01*step.*(s-BestNest.CPnLoc);

     s=s+stepsize.*randn(size(s));
</pre><h2>Application of simple constraints 1<a name="9"></a></h2><p>function s=simplebounds(s,Lb,Ub) Apply the lower bound</p><pre class="codeinput">     ns_tmp=s;
     I=ns_tmp&lt;User.Lb;
     ns_tmp(I)=User.Lb(I);

     <span class="comment">% Apply the upper bounds</span>
     J=ns_tmp&gt;User.Ub;
     ns_tmp(J)=User.Ub(J);
     <span class="comment">% Update th is new move</span>
     s=ns_tmp;
     <span class="comment">% end of simplebounds</span>

  New_Nest(j).CPnLoc=round(s);       <span class="comment">% Calling simplebounds</span>

  New_DistLoadFlowCPSolution=powerflowCP(New_Nest(j).CPnLoc(1,1),New_Nest(j).CPnLoc(1,2));

       New_Nest(j).CostPLos=[New_DistLoadFlowCPSolution.PtLosskW];
       New_Nest(j).CostPbrLos=[New_DistLoadFlowCPSolution.Pbrloss];
       New_Nest(j).CostVact=[New_DistLoadFlowCPSolution.Vactual];
       New_Nest(j).CostVolt=[New_DistLoadFlowCPSolution.VmagPU];
       New_Nest(j).CostVSI=[New_DistLoadFlowCPSolution.VSI];
       New_Nest(j).CostMinVolt=[New_DistLoadFlowCPSolution.minVSI];
       New_Nest(j).CostLSF=[New_DistLoadFlowCPSolution.LSF];

       New_Nest(j).CostVDI=[New_DistLoadFlowCPSolution.VDI];
       New_Nest(j).CostVDIsum=[New_DistLoadFlowCPSolution.VDIsum];

       New_Nest(j).CostVangle=[New_DistLoadFlowCPSolution.Vangle];
       New_Nest(j).CostQtLos=[New_DistLoadFlowCPSolution.QtLosskVAr];
       New_Nest(j).CostQbrLos=[New_DistLoadFlowCPSolution.Qbrloss];
       New_Nest(j).CostSLos=[New_DistLoadFlowCPSolution.SLosskVA];
</pre><pre class="codeinput"><span class="keyword">end</span>
</pre><h2>end of get_cuckoos<a name="11"></a></h2><h2>Geting Current best Solution 2<a name="12"></a></h2><p>calling get_best_nest again... but using New_Nest.Position as input 2nd arguement</p><pre class="codeinput"><span class="keyword">for</span> j=1:User.NumNest
<span class="comment">%     Nest(j).Cost=feval(User.Function,New_Nest(j).Position);</span>

 Nest(j).PLosVolt=feval(User.Function,<span class="keyword">...</span>
            New_Nest(j).CostPLos,New_Nest(j).CostLSF);
<span class="comment">%      Nest(j).PLosVolt=feval(User.Function,...</span>
<span class="comment">%             New_Nest(j).CostPLos,New_Nest(j).CostMinVolt,New_Nest(j).CostQtLos);</span>

    <span class="keyword">if</span> Nest(j).PLosVolt&lt;=fitness(j)
        fitness(j)=Nest(j).PLosVolt;
<span class="comment">%         Nest(j).CPnLoc=New_Nest(j).CPnLoc;</span>
          Nest(j)=New_Nest(j);
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">% Find the current best</span>
[~,K]=min(fitness) ;
BestNest.CPnLoc=Nest(K).CPnLoc;
BestNest.CostPLos       =    Nest(K).CostPLos;
        BestNest.CostPbrLos     =    Nest(K).CostPbrLos;
        BestNest.CostVact       =    Nest(K).CostVact;
        BestNest.CostVolt       =    Nest(K).CostVolt;
        BestNest.CostVSI        =    Nest(K).CostVSI;
        BestNest.CostMinVolt    =    Nest(K).CostMinVolt;
        BestNest.CostLSF        =    Nest(K).CostLSF;

         BestNest.CostVDI        =    Nest(K).CostVDI;
         BestNest.CostVDIsum        =    Nest(K).CostVDIsum;

        BestNest.CostVangle     =    Nest(K).CostVangle;
        BestNest.CostQtLos      =    Nest(K).CostQtLos;
        BestNest.CostQbrLos     =    Nest(K).CostQbrLos;
        BestNest.CostSLos       =    Nest(K).CostSLos;
<span class="comment">% End of calling get_best_nest again... but using new_nest as input arguement</span>
</pre><h2>function new_nest=empty_nests(nest,Lb,Ub,pa) ;<a name="13"></a></h2><pre class="codeinput"><span class="comment">%.............. Discovery and randomization...............</span>

<span class="comment">%............ A fraction of worse nests are discovered with a probability pa..............</span>

<span class="comment">% Discovered or not -- a status vector</span>
<span class="comment">% Converting structure field position to array matrix of NumNest by</span>
<span class="comment">% NumbVar</span>
arrayNestCPnLoc=cell2mat({Nest.CPnLoc}.');
K=rand(size(arrayNestCPnLoc))&gt;pa;

<span class="comment">% In the real world, if a cuckoo's egg is very similar to a host's eggs, then</span>
<span class="comment">% this cuckoo's egg is less likely to be discovered, thus the fitness should</span>
<span class="comment">% be related to the difference in solutions.  Therefore, it is a good idea</span>
<span class="comment">% to do a random walk in a biased way with some random step sizes.</span>
</pre><h2>New solution by biased/selective random walks<a name="14"></a></h2><pre class="codeinput">NumbaofNest=size(arrayNestCPnLoc,1);          <span class="comment">%NumbaofNest = User.NumNest</span>
nestn1=arrayNestCPnLoc(randperm(NumbaofNest),:);
nestn2=arrayNestCPnLoc(randperm(NumbaofNest),:);
Nstepsize=rand*(nestn1-nestn2);
new_arrayNestCPnLoc=arrayNestCPnLoc+Nstepsize.*K;

<span class="keyword">for</span> j=1:size(new_arrayNestCPnLoc,1)
     Ns=new_arrayNestCPnLoc(j,:);
     <span class="comment">%Application of simple constraints 2</span>
     <span class="comment">% Apply the lower bound</span>
     Nns_tmp=Ns;
     nI=Nns_tmp&lt;User.Lb;
     Nns_tmp(nI)=User.Lb(nI);

     <span class="comment">% Apply the upper bounds</span>
     nJ=Nns_tmp&gt;User.Ub;
     Nns_tmp(nJ)=User.Ub(nJ);
     <span class="comment">% Update this new move</span>
     Ns=Nns_tmp;
     <span class="comment">% end of simplebounds</span>
     New_Nest(j).CPnLoc=round(Ns);

     New_DistLoadFlowCPSolution=powerflowCP(New_Nest(j).CPnLoc(1,1),New_Nest(j).CPnLoc(1,2));

       New_Nest(j).CostPLos=[New_DistLoadFlowCPSolution.PtLosskW];
       New_Nest(j).CostPbrLos=[New_DistLoadFlowCPSolution.Pbrloss];
       New_Nest(j).CostVact=[New_DistLoadFlowCPSolution.Vactual];
       New_Nest(j).CostVolt=[New_DistLoadFlowCPSolution.VmagPU];
       New_Nest(j).CostVSI=[New_DistLoadFlowCPSolution.VSI];
       New_Nest(j).CostMinVolt=[New_DistLoadFlowCPSolution.minVSI];
       New_Nest(j).CostLSF=[New_DistLoadFlowCPSolution.LSF];

       New_Nest(j).CostVDI=[New_DistLoadFlowCPSolution.VDI];
       New_Nest(j).CostVDIsum=[New_DistLoadFlowCPSolution.VDIsum];

       New_Nest(j).CostVangle=[New_DistLoadFlowCPSolution.Vangle];
       New_Nest(j).CostQtLos=[New_DistLoadFlowCPSolution.QtLosskVAr];
       New_Nest(j).CostQbrLos=[New_DistLoadFlowCPSolution.Qbrloss];
       New_Nest(j).CostSLos=[New_DistLoadFlowCPSolution.SLosskVA];
<span class="keyword">end</span>
</pre><h2>Geting Current best Solution 3<a name="15"></a></h2><p>calling get_best_nest again... but using New_Nest.Position as input 2nd arguement</p><pre class="codeinput"><span class="keyword">for</span> j=1:User.NumNest
<span class="comment">%     New_Nest(j).Cost=feval(User.Function,New_Nest(j).Position);</span>

 New_Nest(j).PLosVolt=feval(User.Function,<span class="keyword">...</span>
            New_Nest(j).CostPLos,New_Nest(j).CostLSF);

<span class="comment">%     New_Nest(j).PLosVolt=feval(User.Function,...</span>
<span class="comment">%             New_Nest(j).CostPLos,New_Nest(j).CostMinVolt,New_Nest(j).CostQtLos);</span>

    <span class="keyword">if</span> New_Nest(j).PLosVolt&lt;=fitness(j)
        fitness(j)=New_Nest(j).PLosVolt;
<span class="comment">%         Nest(j).CPnLoc=New_Nest(j).CPnLoc;</span>
        Nest(j)=New_Nest(j);
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">% Find the current best</span>
[New_BestNest.PLosVolt,K]=min(fitness) ;
New_BestNest.CPnLoc=Nest(K).CPnLoc;

        New_BestNest.CostPLos       =    Nest(K).CostPLos;
        New_BestNest.CostPbrLos     =    Nest(K).CostPbrLos;
        New_BestNest.CostVact       =    Nest(K).CostVact;
        New_BestNest.CostVolt       =    Nest(K).CostVolt;
        New_BestNest.CostVSI        =    Nest(K).CostVSI;
        New_BestNest.CostLSF        =    Nest(K).CostLSF;

         New_BestNest.CostVDI        =    Nest(K).CostVDI;
         New_BestNest.CostVDIsum        =    Nest(K).CostVDIsum;

        New_BestNest.CostMinVolt    =    Nest(K).CostMinVolt;
        New_BestNest.CostVangle     =    Nest(K).CostVangle;
        New_BestNest.CostQtLos      =    Nest(K).CostQtLos;
        New_BestNest.CostQbrLos     =    Nest(K).CostQbrLos;
        New_BestNest.CostSLos       =    Nest(K).CostSLos;
<span class="comment">% End of calling get_best_nest again... but using new_nest as input arguement</span>
    <span class="keyword">if</span> New_BestNest.PLosVolt&lt;BestNest.PLosVolt
<span class="comment">%         BestNest.PLosVolt=New_BestNest.PLosVolt;</span>
<span class="comment">%         BestNest.CPnLoc =New_BestNest.CPnLoc;</span>
        BestNest = New_BestNest;
    <span class="keyword">end</span>


    BestCost(iter)=BestNest.PLosVolt;
    TlineLossPaIter(iter)= BestNest.CostPLos;
    VDIpaIter(iter)= BestNest.CostVDIsum;
    <span class="comment">% Show Iteration Information</span>
    disp([<span class="string">'Iteration '</span> num2str(iter) <span class="string">': Best Cost = '</span> num2str(BestCost(iter))]);
</pre><pre class="codeoutput">Iteration 1: Best Cost = 134.0371
</pre><pre class="codeoutput">Iteration 2: Best Cost = 134.0371
</pre><pre class="codeoutput">Iteration 3: Best Cost = 133.7349
</pre><pre class="codeoutput">Iteration 4: Best Cost = 129.7124
</pre><pre class="codeoutput">Iteration 5: Best Cost = 129.7124
</pre><pre class="codeoutput">Iteration 6: Best Cost = 129.7124
</pre><pre class="codeoutput">Iteration 7: Best Cost = 129.7124
</pre><pre class="codeoutput">Iteration 8: Best Cost = 129.7124
</pre><pre class="codeoutput">Iteration 9: Best Cost = 129.2307
</pre><pre class="codeoutput">Iteration 10: Best Cost = 129.2307
</pre><pre class="codeoutput">Iteration 11: Best Cost = 128.7452
</pre><pre class="codeoutput">Iteration 12: Best Cost = 128.7452
</pre><pre class="codeoutput">Iteration 13: Best Cost = 128.7452
</pre><pre class="codeoutput">Iteration 14: Best Cost = 128.7452
</pre><pre class="codeoutput">Iteration 15: Best Cost = 128.7452
</pre><pre class="codeoutput">Iteration 16: Best Cost = 128.7452
</pre><pre class="codeoutput">Iteration 17: Best Cost = 127.7743
</pre><pre class="codeoutput">Iteration 18: Best Cost = 127.7743
</pre><pre class="codeoutput">Iteration 19: Best Cost = 127.4874
</pre><pre class="codeoutput">Iteration 20: Best Cost = 127.4874
</pre><pre class="codeoutput">Iteration 21: Best Cost = 127.4874
</pre><pre class="codeoutput">Iteration 22: Best Cost = 127.4874
</pre><pre class="codeoutput">Iteration 23: Best Cost = 127.4874
</pre><pre class="codeoutput">Iteration 24: Best Cost = 127.4874
</pre><pre class="codeoutput">Iteration 25: Best Cost = 127.4874
</pre><pre class="codeoutput">Iteration 26: Best Cost = 127.4874
</pre><pre class="codeoutput">Iteration 27: Best Cost = 127.4874
</pre><pre class="codeoutput">Iteration 28: Best Cost = 127.4874
</pre><pre class="codeoutput">Iteration 29: Best Cost = 127.4874
</pre><pre class="codeoutput">Iteration 30: Best Cost = 127.4874
</pre><pre class="codeoutput">Iteration 31: Best Cost = 127.4874
</pre><pre class="codeoutput">Iteration 32: Best Cost = 127.4874
</pre><pre class="codeoutput">Iteration 33: Best Cost = 127.4874
</pre><pre class="codeoutput">Iteration 34: Best Cost = 127.4874
</pre><pre class="codeoutput">Iteration 35: Best Cost = 127.4874
</pre><pre class="codeoutput">Iteration 36: Best Cost = 127.4873
</pre><pre class="codeoutput">Iteration 37: Best Cost = 127.4873
</pre><pre class="codeoutput">Iteration 38: Best Cost = 127.4873
</pre><pre class="codeoutput">Iteration 39: Best Cost = 127.4873
</pre><pre class="codeoutput">Iteration 40: Best Cost = 127.4873
</pre><pre class="codeoutput">Iteration 41: Best Cost = 127.4873
</pre><pre class="codeoutput">Iteration 42: Best Cost = 127.4873
</pre><pre class="codeoutput">Iteration 43: Best Cost = 127.4873
</pre><pre class="codeoutput">Iteration 44: Best Cost = 127.4873
</pre><pre class="codeoutput">Iteration 45: Best Cost = 127.4873
</pre><pre class="codeoutput">Iteration 46: Best Cost = 127.4873
</pre><pre class="codeoutput">Iteration 47: Best Cost = 127.4873
</pre><pre class="codeoutput">Iteration 48: Best Cost = 127.4873
</pre><pre class="codeoutput">Iteration 49: Best Cost = 127.4873
</pre><pre class="codeoutput">Iteration 50: Best Cost = 127.4873
</pre><pre class="codeinput"><span class="keyword">end</span>
<span class="comment">% iteration ends</span>
</pre><h2>Result Display<a name="17"></a></h2><pre class="codeinput">figure (1);
<span class="comment">%plot(BestCost,'LineWidth',2);</span>
semilogy(BestCost,<span class="string">'LineWidth'</span>,2);
xlabel(<span class="string">'Iteration'</span>);
ylabel(<span class="string">'Cost Function (F)'</span>);
grid <span class="string">on</span>;
<span class="comment">% This part save the figure in png format into a folder already created called "Report"</span>
<span class="keyword">if</span> Standard
    title([<span class="string">'Covergence Characteristic for Standard IEEE  '</span>, num2str(bn), <span class="string">' bus'</span>])
    saveas(gcf,[<span class="string">'Report/Covergence_Characteristic_for_IEEE_Standard_bus_'</span>,num2str(bn),<span class="string">'.png'</span>])
<span class="keyword">else</span>
     title([<span class="string">'Covergence Characteristic for '</span>,Bus_Data, num2str(bn), <span class="string">' bus'</span>])
    saveas(gcf,[<span class="string">'Report/Covergence_Characteristic_for_'</span>,Bus_Data,num2str(bn),<span class="string">'_bus'</span>,<span class="string">'.png'</span>])
<span class="keyword">end</span>
<span class="comment">%%----------------------------------------------------</span>
<span class="comment">% figure (2);</span>
<span class="comment">% %plot(BestCost,'LineWidth',2);</span>
<span class="comment">% semilogy(abs(BestCost),'LineWidth',2);</span>
<span class="comment">% xlabel('Iteration');</span>
<span class="comment">% ylabel('Best Cost');</span>
<span class="comment">% grid on;</span>

figure(2)
x=1:bn;
VpCP=BestNest.CostVolt;
VpBase=DistLoadFlowSolution.VmagPU;
plot(x,VpCP,<span class="string">'g-o'</span>,x,VpBase,<span class="string">'r-*'</span>);
xlim([1 bn]);

legend(<span class="string">'Voltage With Capacitor'</span>,<span class="string">'Voltage With No Capacitor'</span>,<span class="string">'Location'</span>,<span class="string">'northeast'</span>)

xlabel(<span class="string">'Bus Number'</span>)
ylabel(<span class="string">'Voltage Profile'</span>)
<span class="keyword">if</span> Standard
    title([<span class="string">'Voltage Profile for IEEE standard '</span>, num2str(bn), <span class="string">' bus'</span>])
    saveas(gcf,[<span class="string">'Report/Voltage_Profile_for_IEEE standard_'</span>,num2str(bn),<span class="string">'_bus'</span>,<span class="string">'.png'</span>])
<span class="keyword">else</span>
    title([<span class="string">'Voltage Profile for '</span>,Bus_Data, num2str(bn), <span class="string">' bus'</span>])
    saveas(gcf,[<span class="string">'Report/Voltage_Profile_for_'</span>,Bus_Data,num2str(bn),<span class="string">'_bus'</span>,<span class="string">'.png'</span>])
<span class="keyword">end</span>
hold <span class="string">on</span>

figure(3)
xv=1:bn-1;
VSIcp=BestNest.CostVSI;
VsiBase=DistLoadFlowSolution.VSI;
plot(xv,VSIcp,<span class="string">'g-o'</span>,xv,VsiBase,<span class="string">'r-*'</span>);
xlim([1 bn-1]);
legend(<span class="string">'VSI With Capacitor'</span>,<span class="string">'VSI With No Capacitor'</span>,<span class="string">'Location'</span>,<span class="string">'northeast'</span>)
xlabel(<span class="string">'Branch Number'</span>)
ylabel(<span class="string">'Voltage Stability Index'</span>)

<span class="keyword">if</span> Standard
    title([<span class="string">'Voltage Stability Index for IEEE standard '</span>, num2str(bn), <span class="string">' bus'</span>])
    saveas(gcf,[<span class="string">'Report/Voltage_Stability_Index_for_IEEE standard_'</span>,num2str(bn),<span class="string">'_bus'</span>,<span class="string">'.png'</span>])
<span class="keyword">else</span>
    title([<span class="string">'Voltage Stability Index for '</span>,Bus_Data, num2str(bn), <span class="string">' bus'</span>])
    saveas(gcf,[<span class="string">'Report/Voltage_Stability_Index_for_'</span>,Bus_Data,num2str(bn),<span class="string">'_bus'</span>,<span class="string">'.png'</span>])
<span class="keyword">end</span>
hold <span class="string">on</span>

figure(4)
PtLossBase=DistLoadFlowSolution.PtLosskW;
PtLossCP=BestNest.CostPLos;
pp=[PtLossBase;PtLossCP];
bar(pp,<span class="string">'DisplayName'</span>,<span class="string">'1=Before Capacitor placement  2=After Capacitor placement'</span>);
ylabel(<span class="string">'Power Loss (kW)'</span>,<span class="string">'FontSize'</span>,11);
legend(<span class="string">'show'</span>);
PercentRedu=((PtLossBase-PtLossCP)/PtLossBase)*100;
<span class="keyword">if</span> Standard
    title([<span class="string">'Total Power Loss for IEEE standard '</span>, num2str(bn), <span class="string">' bus'</span>])
    saveas(gcf,[<span class="string">'Report/Total_Power_Loss_for_IEEE standard_'</span>,num2str(bn),<span class="string">'_bus'</span>,<span class="string">'.png'</span>])
<span class="keyword">else</span>
    title([<span class="string">'Total Power Loss for '</span>,Bus_Data, num2str(bn), <span class="string">' bus'</span>])
    saveas(gcf,[<span class="string">'Report/Total_Power_Loss_for_'</span>,Bus_Data,num2str(bn),<span class="string">'_bus'</span>,<span class="string">'.png'</span>])
<span class="keyword">end</span>

figure(5)
xv=1:bn-1;
LSFcp=BestNest.CostLSF;
LsfBase=DistLoadFlowSolution.LSF;
plot(xv,LSFcp,<span class="string">'g-o'</span>,xv,LsfBase,<span class="string">'r-*'</span>);
xlim([1 bn-1]);
legend(<span class="string">'LSF With Capacitor'</span>,<span class="string">'LSF With No Capacitor'</span>,<span class="string">'Location'</span>,<span class="string">'northeast'</span>)

xlabel(<span class="string">'Branch Number'</span>)
ylabel(<span class="string">'Loss Sensitivity Factor'</span>)

<span class="keyword">if</span> Standard
    title([<span class="string">'Loss Sensitivity Factor for IEEE standard '</span>, num2str(bn), <span class="string">' bus'</span>])
    saveas(gcf,[<span class="string">'Report/Loss_Sensitivity_Factor_for_IEEE standard_'</span>,num2str(bn),<span class="string">'_bus'</span>,<span class="string">'.png'</span>])
<span class="keyword">else</span>
    title([<span class="string">'Loss Sensitivity Factor for '</span>,Bus_Data, num2str(bn), <span class="string">' bus'</span>])
    saveas(gcf,[<span class="string">'Report/Loss_Sensitivity_Factor_for_'</span>,Bus_Data,num2str(bn),<span class="string">'_bus'</span>,<span class="string">'.png'</span>])
<span class="keyword">end</span>
hold <span class="string">on</span>


disp([<span class="string">'The Total Power loss for base case is '</span>, num2str(PtLossBase)])
disp(<span class="string">'****************************************************************'</span>)
disp([<span class="string">'The Total Power loss for after Capacitor placement is '</span>, num2str(PtLossCP)])
disp(<span class="string">'****************************************************************'</span>)
disp([<span class="string">'The Percentage reduction after Capacitor placement is '</span>, num2str(PercentRedu)])

<span class="keyword">if</span> Standard
    save([<span class="string">'CPWorkSpaceIEEEStandard_'</span>,num2str(bn),<span class="string">'_bus'</span>,<span class="string">'.mat'</span>])

<span class="keyword">else</span>
    save([<span class="string">'CPWorkSpace_'</span>,Bus_Data,num2str(bn),<span class="string">'_bus'</span>,<span class="string">'.mat'</span>])
<span class="keyword">end</span>

figure (6);
<span class="comment">%plot(BestCost,'LineWidth',2);</span>
semilogy(TlineLossPaIter,<span class="string">'LineWidth'</span>,2);
xlabel(<span class="string">'Iteration'</span>);
ylabel(<span class="string">'Total Line Loss'</span>);
grid <span class="string">on</span>;
<span class="comment">% This part save the figure in png format into a folder already created called "Report"</span>
<span class="keyword">if</span> Standard
    title([<span class="string">'Total Line Loss for Standard IEEE  '</span>, num2str(bn), <span class="string">' bus'</span>])
    saveas(gcf,[<span class="string">'Report/Total_Line_Loss_for_IEEE_Standard_bus_'</span>,num2str(bn),<span class="string">'.png'</span>])
<span class="keyword">else</span>
     title([<span class="string">'Total Line Loss for '</span>,Bus_Data, num2str(bn), <span class="string">' bus'</span>])
    saveas(gcf,[<span class="string">'Report/Total_Line_Loss_for_'</span>,Bus_Data,num2str(bn),<span class="string">'_bus'</span>,<span class="string">'.png'</span>])
<span class="keyword">end</span>

figure (7);
<span class="comment">%plot(BestCost,'LineWidth',2);</span>
semilogy(VDIpaIter,<span class="string">'LineWidth'</span>,2);
xlabel(<span class="string">'Iteration'</span>);
ylabel(<span class="string">'Total Voltage Deviation'</span>);
grid <span class="string">on</span>;
<span class="comment">% This part save the figure in png format into a folder already created called "Report"</span>
<span class="keyword">if</span> Standard
    title([<span class="string">'Total Voltge Deviation for Standard IEEE  '</span>, num2str(bn), <span class="string">' bus'</span>])
    saveas(gcf,[<span class="string">'Report/Total_Voltage_Deviation_for_IEEE_Standard_bus_'</span>,num2str(bn),<span class="string">'.png'</span>])
<span class="keyword">else</span>
     title([<span class="string">'Total Voltge Deviation for '</span>,Bus_Data, num2str(bn), <span class="string">' bus'</span>])
    saveas(gcf,[<span class="string">'Report/Total_Voltage_Deviation_for_'</span>,Bus_Data,num2str(bn),<span class="string">'_bus'</span>,<span class="string">'.png'</span>])
<span class="keyword">end</span>
toc
</pre><pre class="codeoutput">The Total Power loss for base case is 210.9876
****************************************************************
The Total Power loss for after Capacitor placement is 151.3649
****************************************************************
The Percentage reduction after Capacitor placement is 28.2588
Elapsed time is 506.481257 seconds.
</pre><img vspace="5" hspace="5" src="CuckooPowerCP_01.png" alt=""> <img vspace="5" hspace="5" src="CuckooPowerCP_02.png" alt=""> <img vspace="5" hspace="5" src="CuckooPowerCP_03.png" alt=""> <img vspace="5" hspace="5" src="CuckooPowerCP_04.png" alt=""> <img vspace="5" hspace="5" src="CuckooPowerCP_05.png" alt=""> <img vspace="5" hspace="5" src="CuckooPowerCP_06.png" alt=""> <img vspace="5" hspace="5" src="CuckooPowerCP_07.png" alt=""> <p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2015a</a><br></p></div><!--
##### SOURCE BEGIN #####
clc;clear;close all;
tic
%% User Input
DistLoadFlowSolution=powerflow;
% Function Input
User.Function='ObjfuncPoweRnLSF';
User.NumbVar=4;
% User.Lb=[-20,-10,-5,-1];
% User.Ub=[20,10,5,1];

Standard = true;
Bus_Data = 'Enugu ';
bn=33;

User.MaxIter=50;
User.Lb=[150 1];
User.Ub=[1500 bn];

% User.Lb=[0 0 0];
% User.Ub=[2.0  2  2];
% Cuckoo Input
User.NumNest=25;
%Levy Flight Input
User.beta=3/2;
pa=0.25;

    %% Initializing the Cuckoo Algorithm
SampleNest.CPnLoc=[];
SampleNest.PLosVolt=[];
Nest=repmat(SampleNest,User.NumNest,1);
for i=1:User.NumNest
%     Nest(i).Position=round(User.Lb+(User.Ub-User.Lb).*rand(size(User.Lb)));
    Nest(i).CPnLoc=round(User.Lb+(User.Ub-User.Lb).*rand(size(User.Lb)));
    
       DistLoadFlowCPSolution=powerflowCP(Nest(i).CPnLoc(1,1),Nest(i).CPnLoc(1,2));
    
       Nest(i).CostPLos=[DistLoadFlowCPSolution.PtLosskW];
       Nest(i).CostPbrLos=[DistLoadFlowCPSolution.Pbrloss];
       Nest(i).CostVact=[DistLoadFlowCPSolution.Vactual];
       Nest(i).CostVolt=[DistLoadFlowCPSolution.VmagPU];
       Nest(i).CostVSI=[DistLoadFlowCPSolution.VSI];
       Nest(i).CostMinVolt=[DistLoadFlowCPSolution.minVSI];
       Nest(i).CostLSF=[DistLoadFlowCPSolution.LSF];
       
       Nest(i).CostVDI=[DistLoadFlowCPSolution.VDI];
       Nest(i).CostVDIsum=[DistLoadFlowCPSolution.VDIsum];
       
       Nest(i).CostVangle=[DistLoadFlowCPSolution.Vangle];
       Nest(i).CostQtLos=[DistLoadFlowCPSolution.QtLosskVAr];
       Nest(i).CostQbrLos=[DistLoadFlowCPSolution.Qbrloss];
       Nest(i).CostSLos=[DistLoadFlowCPSolution.SLosskVA];
end

%% Geting Current best Solution 1
fitness=10^10*ones(User.NumNest,1);
% function
% [BestNest.Cost,Bestnest,Nest.Position,fitness]=get_best_nest(Nest.Position,Nest.Position,fitness);
for j=1:User.NumNest
    
    Nest(j).PLosVolt=feval(User.Function,...
            Nest(j).CostPLos,Nest(j).CostLSF);
        
%     Nest(j).PLosVolt=feval(User.Function,...
%             Nest(j).CostPLos,Nest(j).CostMinVolt,Nest(j).CostQtLos);
    if Nest(j).PLosVolt<=fitness(j)
        fitness(j)=Nest(j).PLosVolt;
        Nest(j).CPnLoc=Nest(j).CPnLoc;
    end
end

% Find the current best
[BestNest.PLosVolt,K]=min(fitness) ;
BestNest.CPnLoc=Nest(K).CPnLoc;
        BestNest.CostPLos       =    Nest(K).CostPLos;
        BestNest.CostPbrLos     =    Nest(K).CostPbrLos;
        BestNest.CostVact       =    Nest(K).CostVact;
        BestNest.CostVolt       =    Nest(K).CostVolt;
        BestNest.CostVSI        =    Nest(K).CostVSI;
        BestNest.CostLSF        =    Nest(K).CostLSF;
        
        BestNest.CostVDI        =    Nest(K).CostVDI;
        BestNest.CostVDIsum        =    Nest(K).CostVDIsum;
        
        BestNest.CostMinVolt    =    Nest(K).CostMinVolt;
        BestNest.CostVangle     =    Nest(K).CostVangle;
        BestNest.CostQtLos      =    Nest(K).CostQtLos;
        BestNest.CostQbrLos     =    Nest(K).CostQbrLos;
        BestNest.CostSLos       =    Nest(K).CostSLos;
%end of get_best_nest

New_Nest=Nest; % Just preallocting New_Nest

%% Starting the iteration
for iter =1:User.MaxIter

%% Generate new solutions (but keep the current best)

%fuction New_Nest.Postion=get_cuckoos(Nest.Position,Bestnest.Position,User.Lb,User.Ub);
% Note arg1 is calling in the number os nest (i.e Nest.Postion=User.NumNest)
sigma=(gamma(1+User.beta)*sin(pi*User.beta/2)/(gamma((1+User.beta)/2)*User.beta*2^((User.beta-1)/2)))^(1/User.beta);
for j=1:User.NumNest
    % implementing Levy Flight for each nest
    s=Nest(j).CPnLoc;
    
     % Levy flights by Mantegna's algorithm
    u=randn(size(s))*sigma;
    v=randn(size(s));
    step=u./abs(v).^(1/User.beta); 
    
    stepsize=0.01*step.*(s-BestNest.CPnLoc);
    
     s=s+stepsize.*randn(size(s));
     
     %% Application of simple constraints 1
     % function s=simplebounds(s,Lb,Ub)
     % Apply the lower bound
     ns_tmp=s;
     I=ns_tmp<User.Lb;
     ns_tmp(I)=User.Lb(I);
     
     % Apply the upper bounds
     J=ns_tmp>User.Ub;
     ns_tmp(J)=User.Ub(J);
     % Update th is new move
     s=ns_tmp;
     % end of simplebounds
  
  New_Nest(j).CPnLoc=round(s);       % Calling simplebounds
  
  New_DistLoadFlowCPSolution=powerflowCP(New_Nest(j).CPnLoc(1,1),New_Nest(j).CPnLoc(1,2));
    
       New_Nest(j).CostPLos=[New_DistLoadFlowCPSolution.PtLosskW];
       New_Nest(j).CostPbrLos=[New_DistLoadFlowCPSolution.Pbrloss];
       New_Nest(j).CostVact=[New_DistLoadFlowCPSolution.Vactual];
       New_Nest(j).CostVolt=[New_DistLoadFlowCPSolution.VmagPU];
       New_Nest(j).CostVSI=[New_DistLoadFlowCPSolution.VSI];
       New_Nest(j).CostMinVolt=[New_DistLoadFlowCPSolution.minVSI];
       New_Nest(j).CostLSF=[New_DistLoadFlowCPSolution.LSF];
       
       New_Nest(j).CostVDI=[New_DistLoadFlowCPSolution.VDI];
       New_Nest(j).CostVDIsum=[New_DistLoadFlowCPSolution.VDIsum];
       
       New_Nest(j).CostVangle=[New_DistLoadFlowCPSolution.Vangle];
       New_Nest(j).CostQtLos=[New_DistLoadFlowCPSolution.QtLosskVAr];
       New_Nest(j).CostQbrLos=[New_DistLoadFlowCPSolution.Qbrloss];
       New_Nest(j).CostSLos=[New_DistLoadFlowCPSolution.SLosskVA];
end

%% end of get_cuckoos

%% Geting Current best Solution 2
% calling get_best_nest again... but using New_Nest.Position as input 2nd arguement
for j=1:User.NumNest
%     Nest(j).Cost=feval(User.Function,New_Nest(j).Position);
    
 Nest(j).PLosVolt=feval(User.Function,...
            New_Nest(j).CostPLos,New_Nest(j).CostLSF);
%      Nest(j).PLosVolt=feval(User.Function,...
%             New_Nest(j).CostPLos,New_Nest(j).CostMinVolt,New_Nest(j).CostQtLos);
    
    if Nest(j).PLosVolt<=fitness(j)
        fitness(j)=Nest(j).PLosVolt;
%         Nest(j).CPnLoc=New_Nest(j).CPnLoc;
          Nest(j)=New_Nest(j);
    end
end

% Find the current best
[~,K]=min(fitness) ;
BestNest.CPnLoc=Nest(K).CPnLoc;
BestNest.CostPLos       =    Nest(K).CostPLos;
        BestNest.CostPbrLos     =    Nest(K).CostPbrLos;
        BestNest.CostVact       =    Nest(K).CostVact;
        BestNest.CostVolt       =    Nest(K).CostVolt;
        BestNest.CostVSI        =    Nest(K).CostVSI;
        BestNest.CostMinVolt    =    Nest(K).CostMinVolt;
        BestNest.CostLSF        =    Nest(K).CostLSF;
        
         BestNest.CostVDI        =    Nest(K).CostVDI;
         BestNest.CostVDIsum        =    Nest(K).CostVDIsum;
        
        BestNest.CostVangle     =    Nest(K).CostVangle;
        BestNest.CostQtLos      =    Nest(K).CostQtLos;
        BestNest.CostQbrLos     =    Nest(K).CostQbrLos;
        BestNest.CostSLos       =    Nest(K).CostSLos;
% End of calling get_best_nest again... but using new_nest as input arguement

%% function new_nest=empty_nests(nest,Lb,Ub,pa) ;
%.............. Discovery and randomization...............

%............ A fraction of worse nests are discovered with a probability pa..............

% Discovered or not REPLACE_WITH_DASH_DASH a status vector
% Converting structure field position to array matrix of NumNest by
% NumbVar
arrayNestCPnLoc=cell2mat({Nest.CPnLoc}.');
K=rand(size(arrayNestCPnLoc))>pa;

% In the real world, if a cuckoo's egg is very similar to a host's eggs, then 
% this cuckoo's egg is less likely to be discovered, thus the fitness should 
% be related to the difference in solutions.  Therefore, it is a good idea 
% to do a random walk in a biased way with some random step sizes. 

%% New solution by biased/selective random walks
NumbaofNest=size(arrayNestCPnLoc,1);          %NumbaofNest = User.NumNest
nestn1=arrayNestCPnLoc(randperm(NumbaofNest),:);
nestn2=arrayNestCPnLoc(randperm(NumbaofNest),:);
Nstepsize=rand*(nestn1-nestn2);
new_arrayNestCPnLoc=arrayNestCPnLoc+Nstepsize.*K;

for j=1:size(new_arrayNestCPnLoc,1)
     Ns=new_arrayNestCPnLoc(j,:);
     %Application of simple constraints 2
     % Apply the lower bound 
     Nns_tmp=Ns;
     nI=Nns_tmp<User.Lb;
     Nns_tmp(nI)=User.Lb(nI);
     
     % Apply the upper bounds
     nJ=Nns_tmp>User.Ub;
     Nns_tmp(nJ)=User.Ub(nJ);
     % Update this new move
     Ns=Nns_tmp;
     % end of simplebounds
     New_Nest(j).CPnLoc=round(Ns); 
     
     New_DistLoadFlowCPSolution=powerflowCP(New_Nest(j).CPnLoc(1,1),New_Nest(j).CPnLoc(1,2));
    
       New_Nest(j).CostPLos=[New_DistLoadFlowCPSolution.PtLosskW];
       New_Nest(j).CostPbrLos=[New_DistLoadFlowCPSolution.Pbrloss];
       New_Nest(j).CostVact=[New_DistLoadFlowCPSolution.Vactual];
       New_Nest(j).CostVolt=[New_DistLoadFlowCPSolution.VmagPU];
       New_Nest(j).CostVSI=[New_DistLoadFlowCPSolution.VSI];
       New_Nest(j).CostMinVolt=[New_DistLoadFlowCPSolution.minVSI];
       New_Nest(j).CostLSF=[New_DistLoadFlowCPSolution.LSF];
       
       New_Nest(j).CostVDI=[New_DistLoadFlowCPSolution.VDI];
       New_Nest(j).CostVDIsum=[New_DistLoadFlowCPSolution.VDIsum];
       
       New_Nest(j).CostVangle=[New_DistLoadFlowCPSolution.Vangle];
       New_Nest(j).CostQtLos=[New_DistLoadFlowCPSolution.QtLosskVAr];
       New_Nest(j).CostQbrLos=[New_DistLoadFlowCPSolution.Qbrloss];
       New_Nest(j).CostSLos=[New_DistLoadFlowCPSolution.SLosskVA];
end

%% Geting Current best Solution 3
% calling get_best_nest again... but using New_Nest.Position as input 2nd arguement
for j=1:User.NumNest
%     New_Nest(j).Cost=feval(User.Function,New_Nest(j).Position);
    
 New_Nest(j).PLosVolt=feval(User.Function,...
            New_Nest(j).CostPLos,New_Nest(j).CostLSF);

%     New_Nest(j).PLosVolt=feval(User.Function,...
%             New_Nest(j).CostPLos,New_Nest(j).CostMinVolt,New_Nest(j).CostQtLos);
    
    if New_Nest(j).PLosVolt<=fitness(j)
        fitness(j)=New_Nest(j).PLosVolt;
%         Nest(j).CPnLoc=New_Nest(j).CPnLoc;
        Nest(j)=New_Nest(j);
    end
end

% Find the current best
[New_BestNest.PLosVolt,K]=min(fitness) ;
New_BestNest.CPnLoc=Nest(K).CPnLoc;

        New_BestNest.CostPLos       =    Nest(K).CostPLos;
        New_BestNest.CostPbrLos     =    Nest(K).CostPbrLos;
        New_BestNest.CostVact       =    Nest(K).CostVact;
        New_BestNest.CostVolt       =    Nest(K).CostVolt;
        New_BestNest.CostVSI        =    Nest(K).CostVSI;
        New_BestNest.CostLSF        =    Nest(K).CostLSF;
        
         New_BestNest.CostVDI        =    Nest(K).CostVDI;
         New_BestNest.CostVDIsum        =    Nest(K).CostVDIsum;
        
        New_BestNest.CostMinVolt    =    Nest(K).CostMinVolt;
        New_BestNest.CostVangle     =    Nest(K).CostVangle;
        New_BestNest.CostQtLos      =    Nest(K).CostQtLos;
        New_BestNest.CostQbrLos     =    Nest(K).CostQbrLos;
        New_BestNest.CostSLos       =    Nest(K).CostSLos;
% End of calling get_best_nest again... but using new_nest as input arguement
    if New_BestNest.PLosVolt<BestNest.PLosVolt
%         BestNest.PLosVolt=New_BestNest.PLosVolt;
%         BestNest.CPnLoc =New_BestNest.CPnLoc;
        BestNest = New_BestNest;
    end
    
    
    BestCost(iter)=BestNest.PLosVolt;
    TlineLossPaIter(iter)= BestNest.CostPLos;
    VDIpaIter(iter)= BestNest.CostVDIsum;
    % Show Iteration Information
    disp(['Iteration ' num2str(iter) ': Best Cost = ' num2str(BestCost(iter))]);
    
end
% iteration ends
%% Result Display
figure (1);
%plot(BestCost,'LineWidth',2);
semilogy(BestCost,'LineWidth',2);
xlabel('Iteration');
ylabel('Cost Function (F)');
grid on;
% This part save the figure in png format into a folder already created called "Report"
if Standard
    title(['Covergence Characteristic for Standard IEEE  ', num2str(bn), ' bus'])
    saveas(gcf,['Report/Covergence_Characteristic_for_IEEE_Standard_bus_',num2str(bn),'.png'])
else
     title(['Covergence Characteristic for ',Bus_Data, num2str(bn), ' bus'])
    saveas(gcf,['Report/Covergence_Characteristic_for_',Bus_Data,num2str(bn),'_bus','.png'])
end
%%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
% figure (2);
% %plot(BestCost,'LineWidth',2);
% semilogy(abs(BestCost),'LineWidth',2);
% xlabel('Iteration');
% ylabel('Best Cost');
% grid on;

figure(2)
x=1:bn;
VpCP=BestNest.CostVolt;
VpBase=DistLoadFlowSolution.VmagPU;
plot(x,VpCP,'g-o',x,VpBase,'r-*');
xlim([1 bn]);

legend('Voltage With Capacitor','Voltage With No Capacitor','Location','northeast')

xlabel('Bus Number')
ylabel('Voltage Profile')
if Standard
    title(['Voltage Profile for IEEE standard ', num2str(bn), ' bus'])
    saveas(gcf,['Report/Voltage_Profile_for_IEEE standard_',num2str(bn),'_bus','.png'])
else
    title(['Voltage Profile for ',Bus_Data, num2str(bn), ' bus'])
    saveas(gcf,['Report/Voltage_Profile_for_',Bus_Data,num2str(bn),'_bus','.png'])
end
hold on

figure(3)
xv=1:bn-1;
VSIcp=BestNest.CostVSI;
VsiBase=DistLoadFlowSolution.VSI;
plot(xv,VSIcp,'g-o',xv,VsiBase,'r-*');
xlim([1 bn-1]);
legend('VSI With Capacitor','VSI With No Capacitor','Location','northeast')
xlabel('Branch Number')
ylabel('Voltage Stability Index')

if Standard
    title(['Voltage Stability Index for IEEE standard ', num2str(bn), ' bus'])
    saveas(gcf,['Report/Voltage_Stability_Index_for_IEEE standard_',num2str(bn),'_bus','.png'])
else
    title(['Voltage Stability Index for ',Bus_Data, num2str(bn), ' bus'])
    saveas(gcf,['Report/Voltage_Stability_Index_for_',Bus_Data,num2str(bn),'_bus','.png'])
end
hold on

figure(4)
PtLossBase=DistLoadFlowSolution.PtLosskW;
PtLossCP=BestNest.CostPLos;
pp=[PtLossBase;PtLossCP];
bar(pp,'DisplayName','1=Before Capacitor placement  2=After Capacitor placement');
ylabel('Power Loss (kW)','FontSize',11);
legend('show');
PercentRedu=((PtLossBase-PtLossCP)/PtLossBase)*100;
if Standard
    title(['Total Power Loss for IEEE standard ', num2str(bn), ' bus'])
    saveas(gcf,['Report/Total_Power_Loss_for_IEEE standard_',num2str(bn),'_bus','.png'])
else
    title(['Total Power Loss for ',Bus_Data, num2str(bn), ' bus'])
    saveas(gcf,['Report/Total_Power_Loss_for_',Bus_Data,num2str(bn),'_bus','.png'])
end

figure(5)
xv=1:bn-1;
LSFcp=BestNest.CostLSF;
LsfBase=DistLoadFlowSolution.LSF;
plot(xv,LSFcp,'g-o',xv,LsfBase,'r-*');
xlim([1 bn-1]);
legend('LSF With Capacitor','LSF With No Capacitor','Location','northeast')

xlabel('Branch Number')
ylabel('Loss Sensitivity Factor')

if Standard
    title(['Loss Sensitivity Factor for IEEE standard ', num2str(bn), ' bus'])
    saveas(gcf,['Report/Loss_Sensitivity_Factor_for_IEEE standard_',num2str(bn),'_bus','.png'])
else
    title(['Loss Sensitivity Factor for ',Bus_Data, num2str(bn), ' bus'])
    saveas(gcf,['Report/Loss_Sensitivity_Factor_for_',Bus_Data,num2str(bn),'_bus','.png'])
end
hold on


disp(['The Total Power loss for base case is ', num2str(PtLossBase)])
disp('****************************************************************')
disp(['The Total Power loss for after Capacitor placement is ', num2str(PtLossCP)])
disp('****************************************************************')
disp(['The Percentage reduction after Capacitor placement is ', num2str(PercentRedu)])

if Standard
    save(['CPWorkSpaceIEEEStandard_',num2str(bn),'_bus','.mat'])
   
else
    save(['CPWorkSpace_',Bus_Data,num2str(bn),'_bus','.mat'])
end

figure (6);
%plot(BestCost,'LineWidth',2);
semilogy(TlineLossPaIter,'LineWidth',2);
xlabel('Iteration');
ylabel('Total Line Loss');
grid on;
% This part save the figure in png format into a folder already created called "Report"
if Standard
    title(['Total Line Loss for Standard IEEE  ', num2str(bn), ' bus'])
    saveas(gcf,['Report/Total_Line_Loss_for_IEEE_Standard_bus_',num2str(bn),'.png'])
else
     title(['Total Line Loss for ',Bus_Data, num2str(bn), ' bus'])
    saveas(gcf,['Report/Total_Line_Loss_for_',Bus_Data,num2str(bn),'_bus','.png'])
end

figure (7);
%plot(BestCost,'LineWidth',2);
semilogy(VDIpaIter,'LineWidth',2);
xlabel('Iteration');
ylabel('Total Voltage Deviation');
grid on;
% This part save the figure in png format into a folder already created called "Report"
if Standard
    title(['Total Voltge Deviation for Standard IEEE  ', num2str(bn), ' bus'])
    saveas(gcf,['Report/Total_Voltage_Deviation_for_IEEE_Standard_bus_',num2str(bn),'.png'])
else
     title(['Total Voltge Deviation for ',Bus_Data, num2str(bn), ' bus'])
    saveas(gcf,['Report/Total_Voltage_Deviation_for_',Bus_Data,num2str(bn),'_bus','.png'])
end
toc
##### SOURCE END #####
--></body></html>